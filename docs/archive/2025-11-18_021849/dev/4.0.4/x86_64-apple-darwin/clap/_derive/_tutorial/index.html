<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Documentation: Derive Tutorial"><meta name="keywords" content="rust, rustlang, rust-lang, _tutorial"><title>clap::_derive::_tutorial - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="/normalize-20220928-1.66.0-nightly-ce7f0f1aa.css"><link rel="stylesheet" href="/rustdoc-20220928-1.66.0-nightly-ce7f0f1aa.css" id="mainThemeStyle"><link rel="stylesheet" href="/ayu-20220928-1.66.0-nightly-ce7f0f1aa.css" disabled><link rel="stylesheet" href="/dark-20220928-1.66.0-nightly-ce7f0f1aa.css" disabled><link rel="stylesheet" href="/light-20220928-1.66.0-nightly-ce7f0f1aa.css" id="themeStyle"><script id="default-settings" ></script><script src="/storage-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><script defer src="/main-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><script defer src="../../../scrape-examples-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><noscript><link rel="stylesheet" href="/noscript-20220928-1.66.0-nightly-ce7f0f1aa.css"></noscript><link rel="alternate icon" type="image/png" href="/favicon-16x16-20220928-1.66.0-nightly-ce7f0f1aa.png"><link rel="alternate icon" type="image/png" href="/favicon-32x32-20220928-1.66.0-nightly-ce7f0f1aa.png"><link rel="icon" type="image/svg+xml" href="/favicon-20220928-1.66.0-nightly-ce7f0f1aa.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../clap/index.html"><div class="logo-container"><img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../clap/index.html"><div class="logo-container">
                    <img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></div></a><h2 class="location"><a href="#">Module _tutorial</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../clap/index.html">
                        <img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="/wheel-20220928-1.66.0-nightly-ce7f0f1aa.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">clap</a>::<wbr><a href="../index.html">_derive</a>::<wbr><a class="mod" href="#">_tutorial</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="/clipboard-20220928-1.66.0-nightly-ce7f0f1aa.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../src/clap/_derive/_tutorial.rs.html#10-226">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unstable-doc</code></strong> only.</div></span><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="documentation-derive-tutorial"><a href="#documentation-derive-tutorial">Documentation: Derive Tutorial</a></h2>
<ol>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#configuring-the-parser">Configuring the Parser</a></li>
<li><a href="#adding-arguments">Adding Arguments</a>
<ol>
<li><a href="#positionals">Positionals</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#flags">Flags</a></li>
<li><a href="#subcommands">Subcommands</a></li>
<li><a href="#defaults">Defaults</a></li>
</ol>
</li>
<li>Validation
<ol>
<li><a href="#enumerated-values">Enumerated values</a></li>
<li><a href="#validated-values">Validated values</a></li>
<li><a href="#argument-relations">Argument Relations</a></li>
<li><a href="#custom-validation">Custom Validation</a></li>
</ol>
</li>
<li><a href="#testing">Testing</a></li>
</ol>
<p>See also</p>
<ul>
<li><a href="../../_faq/index.html#when-should-i-use-the-builder-vs-derive-apis" title="crate::_faq">FAQ: When should I use the builder vs derive APIs?</a></li>
<li>The <a href="../_cookbook/index.html" title="crate::_cookbook">cookbook</a> for more application-focused examples</li>
</ul>
<h3 id="quick-start"><a href="#quick-start">Quick Start</a></h3>
<p>You can create an application declaratively with a <code>struct</code> and some
attributes.  <strong>This requires enabling the <a href="../../_features/index.html" title="crate::_features"><code>derive</code> feature flag</a>.</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::{Parser, Subcommand};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// Optional name to operate on
    </span>name: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="doccomment">/// Sets a custom config file
    </span><span class="attribute">#[arg(short, long, value_name = <span class="string">&quot;FILE&quot;</span>)]
    </span>config: <span class="prelude-ty">Option</span>&lt;PathBuf&gt;,

    <span class="doccomment">/// Turn debugging information on
    </span><span class="attribute">#[arg(short, long, action = clap::ArgAction::Count)]
    </span>debug: u8,

    <span class="attribute">#[command(subcommand)]
    </span>command: <span class="prelude-ty">Option</span>&lt;Commands&gt;,
}

<span class="attribute">#[derive(Subcommand)]
</span><span class="kw">enum </span>Commands {
    <span class="doccomment">/// does testing things
    </span>Test {
        <span class="doccomment">/// lists test values
        </span><span class="attribute">#[arg(short, long)]
        </span>list: bool,
    },
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="comment">// You can check the value provided by positional arguments, or option arguments
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(name) = cli.name.as_deref() {
        <span class="macro">println!</span>(<span class="string">&quot;Value for name: {}&quot;</span>, name);
    }

    <span class="kw">if let </span><span class="prelude-val">Some</span>(config_path) = cli.config.as_deref() {
        <span class="macro">println!</span>(<span class="string">&quot;Value for config: {}&quot;</span>, config_path.display());
    }

    <span class="comment">// You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    </span><span class="kw">match </span>cli.debug {
        <span class="number">0 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is off&quot;</span>),
        <span class="number">1 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is kind of on&quot;</span>),
        <span class="number">2 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is on&quot;</span>),
        <span class="kw">_ </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class="comment">// You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    </span><span class="kw">match </span><span class="kw-2">&amp;</span>cli.command {
        <span class="prelude-val">Some</span>(Commands::Test { list }) =&gt; {
            <span class="kw">if </span><span class="kw-2">*</span>list {
                <span class="macro">println!</span>(<span class="string">&quot;Printing testing lists...&quot;</span>);
            } <span class="kw">else </span>{
                <span class="macro">println!</span>(<span class="string">&quot;Not printing testing lists...&quot;</span>);
            }
        }
        <span class="prelude-val">None </span>=&gt; {}
    }

    <span class="comment">// Continued program logic goes here...
</span>}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 01_quick_derive[EXE] [OPTIONS] [NAME] [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [NAME]  Optional name to operate on

Options:
  -c, --config &lt;FILE&gt;  Sets a custom config file
  -d, --debug...       Turn debugging information on
  -h, --help           Print help information
  -V, --version        Print version information
</code></pre></div>
<p>By default, the program does nothing:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick_derive
Debug mode is off
</code></pre></div>
<p>But you can mix and match the various features</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick_derive -dd test
Debug mode is on
Not printing testing lists...
</code></pre></div><h3 id="configuring-the-parser"><a href="#configuring-the-parser">Configuring the Parser</a></h3>
<p>You use derive <a href="../../trait.Parser.html" title="crate::Parser"><code>Parser</code></a> to start building a parser.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(name = <span class="string">&quot;MyApp&quot;</span>)]
#[command(author = <span class="string">&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)]
#[command(version = <span class="string">&quot;1.0&quot;</span>)]
#[command(about = <span class="string">&quot;Does awesome things&quot;</span>, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(long)]
    </span>two: String,
    <span class="attribute">#[arg(long)]
    </span>one: String,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;two: {:?}&quot;</span>, cli.two);
    <span class="macro">println!</span>(<span class="string">&quot;one: {:?}&quot;</span>, cli.one);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_apps_derive --help
Does awesome things

Usage: 02_apps_derive[EXE] --two &lt;TWO&gt; --one &lt;ONE&gt;

Options:
      --two &lt;TWO&gt;  
      --one &lt;ONE&gt;  
  -h, --help       Print help information
  -V, --version    Print version information

$ 02_apps_derive --version
MyApp 1.0
</code></pre></div>
<p>You can use <code>#[command(author, version, about)]</code> attribute defaults to fill these fields in from your <code>Cargo.toml</code> file.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)] </span><span class="comment">// Read from `Cargo.toml`
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(long)]
    </span>two: String,
    <span class="attribute">#[arg(long)]
    </span>one: String,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;two: {:?}&quot;</span>, cli.two);
    <span class="macro">println!</span>(<span class="string">&quot;one: {:?}&quot;</span>, cli.one);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_crate_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_crate_derive[EXE] --two &lt;TWO&gt; --one &lt;ONE&gt;

Options:
      --two &lt;TWO&gt;  
      --one &lt;ONE&gt;  
  -h, --help       Print help information
  -V, --version    Print version information

$ 02_crate_derive --version
clap [..]
</code></pre></div>
<p>You can use attributes to change the application level behavior of clap.  Any <a href="../../builder/struct.Command.html" title="crate::Command"><code>Command</code></a> builder function can be used as an attribute.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
#[command(next_line_help = <span class="bool-val">true</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(long)]
    </span>two: String,
    <span class="attribute">#[arg(long)]
    </span>one: String,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;two: {:?}&quot;</span>, cli.two);
    <span class="macro">println!</span>(<span class="string">&quot;one: {:?}&quot;</span>, cli.one);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_app_settings_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_app_settings_derive[EXE] --two &lt;TWO&gt; --one &lt;ONE&gt;

Options:
      --two &lt;TWO&gt;
          
      --one &lt;ONE&gt;
          
  -h, --help
          Print help information
  -V, --version
          Print version information
</code></pre></div><h3 id="adding-arguments"><a href="#adding-arguments">Adding Arguments</a></h3><h4 id="positionals"><a href="#positionals">Positionals</a></h4>
<p>You can have users specify values by their position on the command-line:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, cli.name.as_deref());
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_derive[EXE] [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_03_positional_derive
name: None

$ 03_03_positional_derive bob
name: Some(&quot;bob&quot;)
</code></pre></div>
<p>Note that the default <a href="../../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a> is <a href="../../builder/enum.ArgAction.html#variant.Set" title="crate::ArgAction::Set"><code>Set</code></a>.  To
accept multiple values, use <a href="../../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append"><code>Append</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    name: Vec&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, cli.name);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional_mult_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_mult_derive[EXE] [NAME]...

Arguments:
  [NAME]...  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_03_positional_mult_derive
name: []

$ 03_03_positional_mult_derive bob
name: [&quot;bob&quot;]
</code></pre></div><h4 id="options"><a href="#options">Options</a></h4>
<p>You can name your arguments with a flag:</p>
<ul>
<li>Order doesn’t matter</li>
<li>They can be optional</li>
<li>Intent is clearer</li>
</ul>
<p>The <code>#[arg(short = 'n')]</code> and <code>#[arg(long = &quot;name&quot;)]</code> attributes that define
the flags are <a href="../../trait.Args.html" title="crate::Args"><code>Arg</code></a> methods that are derived from the field name when no value
is specified (<code>#[arg(short)]</code> and <code>#[arg(long)]</code>).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(short, long)]
    </span>name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, cli.name.as_deref());
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_derive[EXE] [OPTIONS]

Options:
  -n, --name &lt;NAME&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 03_02_option_derive
name: None

$ 03_02_option_derive --name bob
name: Some(&quot;bob&quot;)

$ 03_02_option_derive --name=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_derive -n bob
name: Some(&quot;bob&quot;)

$ 03_02_option_derive -n=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_derive -nbob
name: Some(&quot;bob&quot;)
</code></pre></div>
<p>Note that the default <a href="../../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a> is <a href="../../builder/enum.ArgAction.html#variant.Set" title="crate::ArgAction::Set"><code>Set</code></a>.  To
accept multiple occurrences, use <a href="../../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append"><code>Append</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(short, long)]
    </span>name: Vec&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, cli.name);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option_mult_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_mult_derive[EXE] [OPTIONS]

Options:
  -n, --name &lt;NAME&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 03_02_option_mult_derive
name: []

$ 03_02_option_mult_derive --name bob
name: [&quot;bob&quot;]

$ 03_02_option_mult_derive --name=bob
name: [&quot;bob&quot;]

$ 03_02_option_mult_derive -n bob
name: [&quot;bob&quot;]

$ 03_02_option_mult_derive -n=bob
name: [&quot;bob&quot;]

$ 03_02_option_mult_derive -nbob
name: [&quot;bob&quot;]
</code></pre></div><h4 id="flags"><a href="#flags">Flags</a></h4>
<p>Flags can also be switches that can be on/off.  This is enabled via the
<code>#[arg(action = ArgAction::SetTrue)]</code> attribute though this is implied when the field is a
<code>bool</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(short, long)]
    </span>verbose: bool,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, cli.verbose);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_bool_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_bool_derive[EXE] [OPTIONS]

Options:
  -v, --verbose  
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_01_flag_bool_derive
verbose: false

$ 03_01_flag_bool_derive --verbose
verbose: true

$ 03_01_flag_bool_derive --verbose --verbose
? failed
error: The argument &#39;--verbose&#39; was provided more than once, but cannot be used multiple times

Usage: 03_01_flag_bool_derive[EXE] [OPTIONS]

For more information try &#39;--help&#39;
</code></pre></div>
<p>Note that the default <a href="../../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a> for a <code>bool</code> field is
<a href="../../builder/enum.ArgAction.html#variant.SetTrue" title="crate::ArgAction::SetTrue"><code>SetTrue</code></a>.  To accept multiple values, use
<a href="../../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append"><code>Append</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(short, long, action = clap::ArgAction::Count)]
    </span>verbose: u8,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, cli.verbose);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_count_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_count_derive[EXE] [OPTIONS]

Options:
  -v, --verbose...  
  -h, --help        Print help information
  -V, --version     Print version information

$ 03_01_flag_count_derive
verbose: 0

$ 03_01_flag_count_derive --verbose
verbose: 1

$ 03_01_flag_count_derive --verbose --verbose
verbose: 2
</code></pre></div><h4 id="subcommands"><a href="#subcommands">Subcommands</a></h4>
<p>Subcommands are derived with <code>#[derive(Subcommand)]</code> and be added via <code>#[command(subcommand)]</code> attribute. Each
instance of a <a href="../../trait.Subcommand.html" title="crate::Subcommand">Subcommand</a> can have its own version, author(s), Args, and even its own
subcommands.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{Parser, Subcommand};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
#[command(propagate_version = <span class="bool-val">true</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[command(subcommand)]
    </span>command: Commands,
}

<span class="attribute">#[derive(Subcommand)]
</span><span class="kw">enum </span>Commands {
    <span class="doccomment">/// Adds files to myapp
    </span>Add { name: <span class="prelude-ty">Option</span>&lt;String&gt; },
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="comment">// You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    </span><span class="kw">match </span><span class="kw-2">&amp;</span>cli.command {
        Commands::Add { name } =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;&#39;myapp add&#39; was used, name is: {:?}&quot;</span>, name)
        }
    }
}</code></pre></div>
<p>We used a struct-variant to define the <code>add</code> subcommand.
Alternatively, you can use a struct for your subcommand’s arguments:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{Args, Parser, Subcommand};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
#[command(propagate_version = <span class="bool-val">true</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[command(subcommand)]
    </span>command: Commands,
}

<span class="attribute">#[derive(Subcommand)]
</span><span class="kw">enum </span>Commands {
    <span class="doccomment">/// Adds files to myapp
    </span>Add(Add),
}

<span class="attribute">#[derive(Args)]
</span><span class="kw">struct </span>Add {
    name: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="comment">// You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    </span><span class="kw">match </span><span class="kw-2">&amp;</span>cli.command {
        Commands::Add(name) =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;&#39;myapp add&#39; was used, name is: {:?}&quot;</span>, name.name)
        }
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands_derive help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands_derive[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_04_subcommands_derive help add
Adds files to myapp

Usage: 03_04_subcommands_derive[EXE] add [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_04_subcommands_derive add bob
&#39;myapp add&#39; was used, name is: Some(&quot;bob&quot;)
</code></pre></div>
<p>Because we used <code>command: Commands</code> instead of <code>command: Option&lt;Commands&gt;</code>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands_derive
? failed
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands_derive[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help information
  -V, --version  Print version information
</code></pre></div>
<p>Because we added <code>#[command(propagate_version = true)]</code>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands_derive --version
clap [..]

$ 03_04_subcommands_derive add --version
clap-add [..]
</code></pre></div><h4 id="defaults"><a href="#defaults">Defaults</a></h4>
<p>We’ve previously showed that arguments can be <a href="../../builder/struct.Arg.html#method.required" title="crate::Arg::required"><code>required</code></a> or optional.
When optional, you work with a <code>Option</code> and can <code>unwrap_or</code>.  Alternatively, you can
set <code>#[arg(default_value_t)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="attribute">#[arg(default_value_t = <span class="number">2020</span>)]
    </span>port: u16,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;port: {:?}&quot;</span>, cli.port);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_05_default_values_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_05_default_values_derive[EXE] [PORT]

Arguments:
  [PORT]  [default: 2020]

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_05_default_values_derive
port: 2020

$ 03_05_default_values_derive 22
port: 22
</code></pre></div><h3 id="validation"><a href="#validation">Validation</a></h3>
<p>An appropriate default parser/validator will be selected for the field’s type.  See
<a href="../../macro.value_parser.html" title="crate::value_parser!"><code>value_parser!</code></a> for more details.</p>
<h4 id="enumerated-values"><a href="#enumerated-values">Enumerated values</a></h4>
<p>For example, if you have arguments of specific values you want to test for, you can derive
<a href="../../trait.ValueEnum.html" title="crate::ValueEnum"><code>ValueEnum</code></a>.</p>
<p>This allows you specify the valid values for that argument. If the user does not use one of
those specific values, they will receive a graceful exit with error message informing them
of the mistake, and what the possible valid values are</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{Parser, ValueEnum};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// What mode to run the program in
    </span><span class="attribute">#[arg(value_enum)]
    </span>mode: Mode,
}

<span class="attribute">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
</span><span class="kw">enum </span>Mode {
    Fast,
    Slow,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="kw">match </span>cli.mode {
        Mode::Fast =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Hare&quot;</span>);
        }
        Mode::Slow =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Tortoise&quot;</span>);
        }
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_01_enum_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum_derive[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_01_enum_derive fast
Hare

$ 04_01_enum_derive slow
Tortoise

$ 04_01_enum_derive medium
? failed
error: &quot;medium&quot; isn&#39;t a valid value for &#39;&lt;MODE&gt;&#39;
  [possible values: fast, slow]

For more information try &#39;--help&#39;
</code></pre></div><h4 id="validated-values"><a href="#validated-values">Validated values</a></h4>
<p>More generally, you can validate and parse into any data type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// Network port to use
    </span><span class="attribute">#[arg(value_parser = <span class="macro">clap::value_parser!</span>(u16).range(<span class="number">1</span>..))]
    </span>port: u16,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, cli.port);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_parse_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_parse_derive[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_02_parse_derive 22
PORT = 22

$ 04_02_parse_derive foobar
? failed
error: Invalid value &quot;foobar&quot; for &#39;&lt;PORT&gt;&#39;: invalid digit found in string

For more information try &#39;--help&#39;

$ 04_02_parse_derive 0
? failed
error: Invalid value &quot;0&quot; for &#39;&lt;PORT&gt;&#39;: 0 is not in 1..=65535

For more information try &#39;--help&#39;
</code></pre></div>
<p>A custom parser can be used to improve the error messages or provide additional validation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ops::RangeInclusive;

<span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// Network port to use
    </span><span class="attribute">#[arg(value_parser = port_in_range)]
    </span>port: u16,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, cli.port);
}

<span class="kw">const </span>PORT_RANGE: RangeInclusive&lt;usize&gt; = <span class="number">1</span>..=<span class="number">65535</span>;

<span class="kw">fn </span>port_in_range(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;u16, String&gt; {
    <span class="kw">let </span>port: usize = s
        .parse()
        .map_err(|<span class="kw">_</span>| <span class="macro">format!</span>(<span class="string">&quot;`{}` isn&#39;t a port number&quot;</span>, s))<span class="question-mark">?</span>;
    <span class="kw">if </span>PORT_RANGE.contains(<span class="kw-2">&amp;</span>port) {
        <span class="prelude-val">Ok</span>(port <span class="kw">as </span>u16)
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(<span class="macro">format!</span>(
            <span class="string">&quot;Port not in range {}-{}&quot;</span>,
            PORT_RANGE.start(),
            PORT_RANGE.end()
        ))
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_validate_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_validate_derive[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_02_validate_derive 22
PORT = 22

$ 04_02_validate_derive foobar
? failed
error: Invalid value &quot;foobar&quot; for &#39;&lt;PORT&gt;&#39;: `foobar` isn&#39;t a port number

For more information try &#39;--help&#39;

$ 04_02_validate_derive 0
? failed
error: Invalid value &quot;0&quot; for &#39;&lt;PORT&gt;&#39;: Port not in range 1-65535

For more information try &#39;--help&#39;
</code></pre></div>
<p>See <a href="../../builder/struct.Arg.html#method.value_parser" title="crate::Arg::value_parser"><code>Arg::value_parser</code></a> for more details.</p>
<h4 id="argument-relations"><a href="#argument-relations">Argument Relations</a></h4>
<p>You can declare dependencies or conflicts between <a href="../../builder/struct.Arg.html" title="crate::Arg"><code>Arg</code></a>s or even
<a href="../../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s.</p>
<p><a href="../../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s  make it easier to declare relations instead of having to list
each individually, or when you want a rule to apply “any but not all” arguments.</p>
<p>Perhaps the most common use of <a href="../../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s is to require one and <em>only</em> one
argument to be present out of a given set. Imagine that you had multiple arguments, and you
want one of them to be required, but making all of them required isn’t feasible because perhaps
they conflict with each other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{ArgGroup, Parser};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
#[command(group(
            ArgGroup::new(<span class="string">&quot;vers&quot;</span>)
                .required(<span class="bool-val">true</span>)
                .args([<span class="string">&quot;set_ver&quot;</span>, <span class="string">&quot;major&quot;</span>, <span class="string">&quot;minor&quot;</span>, <span class="string">&quot;patch&quot;</span>]</span>),
        ))]
<span class="kw">struct </span>Cli {
    <span class="doccomment">/// set version manually
    </span><span class="attribute">#[arg(long, value_name = <span class="string">&quot;VER&quot;</span>)]
    </span>set_ver: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="doccomment">/// auto inc major
    </span><span class="attribute">#[arg(long)]
    </span>major: bool,

    <span class="doccomment">/// auto inc minor
    </span><span class="attribute">#[arg(long)]
    </span>minor: bool,

    <span class="doccomment">/// auto inc patch
    </span><span class="attribute">#[arg(long)]
    </span>patch: bool,

    <span class="doccomment">/// some regular input
    </span><span class="attribute">#[arg(group = <span class="string">&quot;input&quot;</span>)]
    </span>input_file: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="doccomment">/// some special input argument
    </span><span class="attribute">#[arg(long, group = <span class="string">&quot;input&quot;</span>)]
    </span>spec_in: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="attribute">#[arg(short, requires = <span class="string">&quot;input&quot;</span>)]
    </span>config: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set_ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = cli.set_ver.as_deref() {
        ver.to_string()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (cli.major, cli.minor, cli.patch);
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="kw">_</span>, <span class="kw">_</span>) =&gt; major += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="kw">_</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(config) = cli.config.as_deref() {
        <span class="kw">let </span>input = cli
            .input_file
            .as_deref()
            .unwrap_or_else(|| cli.spec_in.as_deref().unwrap());
        <span class="macro">println!</span>(<span class="string">&quot;Doing work using input {} and config {}&quot;</span>, input, config);
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_03_relations_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_03_relations_derive[EXE] [OPTIONS] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help information
  -V, --version            Print version information

$ 04_03_relations_derive
? failed
error: The following required arguments were not provided:
  &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt;

Usage: 04_03_relations_derive[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_03_relations_derive --major
Version: 2.2.3

$ 04_03_relations_derive --major --minor
? failed
error: The argument &#39;--major&#39; cannot be used with &#39;--minor&#39;

Usage: 04_03_relations_derive[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_03_relations_derive --major -c config.toml
? failed
error: The following required arguments were not provided:
  &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

Usage: 04_03_relations_derive[EXE] -c &lt;CONFIG&gt; &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

For more information try &#39;--help&#39;

$ 04_03_relations_derive --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml
</code></pre></div><h4 id="custom-validation"><a href="#custom-validation">Custom Validation</a></h4>
<p>As a last resort, you can create custom errors with the basics of clap’s formatting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::error::ErrorKind;
<span class="kw">use </span>clap::{CommandFactory, Parser};

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// set version manually
    </span><span class="attribute">#[arg(long, value_name = <span class="string">&quot;VER&quot;</span>)]
    </span>set_ver: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="doccomment">/// auto inc major
    </span><span class="attribute">#[arg(long)]
    </span>major: bool,

    <span class="doccomment">/// auto inc minor
    </span><span class="attribute">#[arg(long)]
    </span>minor: bool,

    <span class="doccomment">/// auto inc patch
    </span><span class="attribute">#[arg(long)]
    </span>patch: bool,

    <span class="doccomment">/// some regular input
    </span>input_file: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="doccomment">/// some special input argument
    </span><span class="attribute">#[arg(long)]
    </span>spec_in: <span class="prelude-ty">Option</span>&lt;String&gt;,

    <span class="attribute">#[arg(short)]
    </span>config: <span class="prelude-ty">Option</span>&lt;String&gt;,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set-ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = cli.set_ver.as_deref() {
        <span class="kw">if </span>cli.major || cli.minor || cli.patch {
            <span class="kw">let </span><span class="kw-2">mut </span>cmd = Cli::command();
            cmd.error(
                ErrorKind::ArgumentConflict,
                <span class="string">&quot;Can&#39;t do relative and absolute version change&quot;</span>,
            )
            .exit();
        }
        ver.to_string()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (cli.major, cli.minor, cli.patch);
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">false</span>) =&gt; major += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; {
                <span class="kw">let </span><span class="kw-2">mut </span>cmd = Cli::command();
                cmd.error(
                    ErrorKind::ArgumentConflict,
                    <span class="string">&quot;Can only modify one version field&quot;</span>,
                )
                .exit();
            }
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(config) = cli.config.as_deref() {
        <span class="kw">let </span>input = cli
            .input_file
            .as_deref()
            <span class="comment">// &#39;or&#39; is preferred to &#39;or_else&#39; here since `Option::as_deref` is &#39;const&#39;
            </span>.or(cli.spec_in.as_deref())
            .unwrap_or_else(|| {
                <span class="kw">let </span><span class="kw-2">mut </span>cmd = Cli::command();
                cmd.error(
                    ErrorKind::MissingRequiredArgument,
                    <span class="string">&quot;INPUT_FILE or --spec-in is required when using --config&quot;</span>,
                )
                .exit()
            });
        <span class="macro">println!</span>(<span class="string">&quot;Doing work using input {} and config {}&quot;</span>, input, config);
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_04_custom_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_04_custom_derive[EXE] [OPTIONS] [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help information
  -V, --version            Print version information

$ 04_04_custom_derive
? failed
error: Can only modify one version field

Usage: clap [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom_derive --major
Version: 2.2.3

$ 04_04_custom_derive --major --minor
? failed
error: Can only modify one version field

Usage: clap [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom_derive --major -c config.toml
? failed
Version: 2.2.3
error: INPUT_FILE or --spec-in is required when using --config

Usage: clap [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom_derive --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml
</code></pre></div><h3 id="testing"><a href="#testing">Testing</a></h3>
<p>clap reports most development errors as <code>debug_assert!</code>s.  Rather than checking every
subcommand, you should have a test that calls
<a href="../../builder/struct.Command.html#method.debug_assert" title="crate::Command::debug_assert"><code>Command::debug_assert</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::Parser;

<span class="attribute">#[derive(Parser)]
#[command(author, version, about, long_about = <span class="prelude-val">None</span>)]
</span><span class="kw">struct </span>Cli {
    <span class="doccomment">/// Network port to use
    </span>port: u16,
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>cli = Cli::parse();

    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, cli.port);
}

<span class="attribute">#[test]
</span><span class="kw">fn </span>verify_cli() {
    <span class="kw">use </span>clap::CommandFactory;
    Cli::command().debug_assert()
}</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="clap" data-themes="ayu,dark,light" data-resource-suffix="-20220928-1.66.0-nightly-ce7f0f1aa" data-rustdoc-version="1.66.0-nightly (ce7f0f1aa 2022-09-28)" ></div></body></html>