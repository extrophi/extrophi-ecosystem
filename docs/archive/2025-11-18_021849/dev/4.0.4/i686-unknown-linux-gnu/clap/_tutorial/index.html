<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Documentation: Builder Tutorial"><meta name="keywords" content="rust, rustlang, rust-lang, _tutorial"><title>clap::_tutorial - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="/SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="/normalize-20220928-1.66.0-nightly-ce7f0f1aa.css"><link rel="stylesheet" href="/rustdoc-20220928-1.66.0-nightly-ce7f0f1aa.css" id="mainThemeStyle"><link rel="stylesheet" href="/ayu-20220928-1.66.0-nightly-ce7f0f1aa.css" disabled><link rel="stylesheet" href="/dark-20220928-1.66.0-nightly-ce7f0f1aa.css" disabled><link rel="stylesheet" href="/light-20220928-1.66.0-nightly-ce7f0f1aa.css" id="themeStyle"><script id="default-settings" ></script><script src="/storage-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><script defer src="/main-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><script defer src="../../scrape-examples-20220928-1.66.0-nightly-ce7f0f1aa.js"></script><noscript><link rel="stylesheet" href="/noscript-20220928-1.66.0-nightly-ce7f0f1aa.css"></noscript><link rel="alternate icon" type="image/png" href="/favicon-16x16-20220928-1.66.0-nightly-ce7f0f1aa.png"><link rel="alternate icon" type="image/png" href="/favicon-32x32-20220928-1.66.0-nightly-ce7f0f1aa.png"><link rel="icon" type="image/svg+xml" href="/favicon-20220928-1.66.0-nightly-ce7f0f1aa.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../clap/index.html"><div class="logo-container"><img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../clap/index.html"><div class="logo-container">
                    <img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></div></a><h2 class="location"><a href="#">Module _tutorial</a></h2><div class="sidebar-elems"></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../clap/index.html">
                        <img src="https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="/wheel-20220928-1.66.0-nightly-ce7f0f1aa.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">clap</a>::<wbr><a class="mod" href="#">_tutorial</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="/clipboard-20220928-1.66.0-nightly-ce7f0f1aa.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/clap/_tutorial.rs.html#10-224">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unstable-doc</code></strong> only.</div></span><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="documentation-builder-tutorial"><a href="#documentation-builder-tutorial">Documentation: Builder Tutorial</a></h2>
<ol>
<li><a href="#quick-start">Quick Start</a></li>
<li><a href="#configuring-the-parser">Configuring the Parser</a></li>
<li><a href="#adding-arguments">Adding Arguments</a>
<ol>
<li><a href="#positionals">Positionals</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#flags">Flags</a></li>
<li><a href="#subcommands">Subcommands</a></li>
<li><a href="#defaults">Defaults</a></li>
</ol>
</li>
<li>Validation
<ol>
<li><a href="#enumerated-values">Enumerated values</a></li>
<li><a href="#validated-values">Validated values</a></li>
<li><a href="#argument-relations">Argument Relations</a></li>
<li><a href="#custom-validation">Custom Validation</a></li>
</ol>
</li>
<li><a href="#testing">Testing</a></li>
</ol>
<p>See also</p>
<ul>
<li><a href="../_faq/index.html#when-should-i-use-the-builder-vs-derive-apis" title="crate::_faq">FAQ: When should I use the builder vs derive APIs?</a></li>
<li>The <a href="../_derive/_cookbook/index.html" title="crate::_cookbook">cookbook</a> for more application-focused examples</li>
</ul>
<h3 id="quick-start"><a href="#quick-start">Quick Start</a></h3>
<p>You can create an application with several arguments using usage strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(<span class="macro">arg!</span>([name] <span class="string">&quot;Optional name to operate on&quot;</span>))
        .arg(
            <span class="macro">arg!</span>(
                -c --config &lt;FILE&gt; <span class="string">&quot;Sets a custom config file&quot;
            </span>)
            <span class="comment">// We don&#39;t have syntax yet for optional options, so manually calling `required`
            </span>.required(<span class="bool-val">false</span>)
            .value_parser(<span class="macro">value_parser!</span>(PathBuf)),
        )
        .arg(<span class="macro">arg!</span>(
            -d --debug ... <span class="string">&quot;Turn debugging information on&quot;
        </span>))
        .subcommand(
            Command::new(<span class="string">&quot;test&quot;</span>)
                .about(<span class="string">&quot;does testing things&quot;</span>)
                .arg(<span class="macro">arg!</span>(-l --list <span class="string">&quot;lists test values&quot;</span>).action(ArgAction::SetTrue)),
        )
        .get_matches();

    <span class="comment">// You can check the value provided by positional arguments, or option arguments
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(name) = matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>) {
        <span class="macro">println!</span>(<span class="string">&quot;Value for name: {}&quot;</span>, name);
    }

    <span class="kw">if let </span><span class="prelude-val">Some</span>(config_path) = matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>) {
        <span class="macro">println!</span>(<span class="string">&quot;Value for config: {}&quot;</span>, config_path.display());
    }

    <span class="comment">// You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    </span><span class="kw">match </span>matches
        .get_one::&lt;u8&gt;(<span class="string">&quot;debug&quot;</span>)
        .expect(<span class="string">&quot;Count&#39;s are defaulted&quot;</span>)
    {
        <span class="number">0 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is off&quot;</span>),
        <span class="number">1 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is kind of on&quot;</span>),
        <span class="number">2 </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Debug mode is on&quot;</span>),
        <span class="kw">_ </span>=&gt; <span class="macro">println!</span>(<span class="string">&quot;Don&#39;t be crazy&quot;</span>),
    }

    <span class="comment">// You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(matches) = matches.subcommand_matches(<span class="string">&quot;test&quot;</span>) {
        <span class="comment">// &quot;$ myapp test&quot; was run
        </span><span class="kw">if </span><span class="kw-2">*</span>matches.get_one::&lt;bool&gt;(<span class="string">&quot;list&quot;</span>).expect(<span class="string">&quot;defaulted by clap&quot;</span>) {
            <span class="comment">// &quot;$ myapp test -l&quot; was run
            </span><span class="macro">println!</span>(<span class="string">&quot;Printing testing lists...&quot;</span>);
        } <span class="kw">else </span>{
            <span class="macro">println!</span>(<span class="string">&quot;Not printing testing lists...&quot;</span>);
        }
    }

    <span class="comment">// Continued program logic goes here...
</span>}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 01_quick[EXE] [OPTIONS] [name] [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [name]  Optional name to operate on

Options:
  -c, --config &lt;FILE&gt;  Sets a custom config file
  -d, --debug...       Turn debugging information on
  -h, --help           Print help information
  -V, --version        Print version information
</code></pre></div>
<p>By default, the program does nothing:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick
Debug mode is off
</code></pre></div>
<p>But you can mix and match the various features</p>
<div class="example-wrap"><pre class="language-console"><code>$ 01_quick -dd test
Debug mode is on
Not printing testing lists...
</code></pre></div><h3 id="configuring-the-parser"><a href="#configuring-the-parser">Configuring the Parser</a></h3>
<p>You use <a href="../builder/struct.Command.html" title="crate::Command"><code>Command</code></a> to start building a parser.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = Command::new(<span class="string">&quot;MyApp&quot;</span>)
        .version(<span class="string">&quot;1.0&quot;</span>)
        .author(<span class="string">&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;</span>)
        .about(<span class="string">&quot;Does awesome things&quot;</span>)
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_apps --help
Does awesome things

Usage: 02_apps[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;  
      --one &lt;VALUE&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 02_apps --version
MyApp 1.0
</code></pre></div>
<p>You can use <a href="../macro.command.html" title="crate::command!"><code>command!()</code></a> to fill these fields in from your <code>Cargo.toml</code>
file.  <strong>This requires the <a href="../_features/index.html" title="crate::_features"><code>cargo</code> feature flag</a>.</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="comment">// requires `cargo` feature, reading name, version, author, and description from `Cargo.toml`
    </span><span class="kw">let </span>matches = <span class="macro">command!</span>()
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_crate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_crate[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;  
      --one &lt;VALUE&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 02_crate --version
clap [..]
</code></pre></div>
<p>You can use <a href="../builder/struct.Command.html" title="crate::Command"><code>Command</code></a> methods to change the application level behavior of
clap.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.next_line_help(<span class="bool-val">true</span>)
        .arg(<span class="macro">arg!</span>(--two &lt;VALUE&gt;).required(<span class="bool-val">true</span>).action(ArgAction::Set))
        .arg(<span class="macro">arg!</span>(--one &lt;VALUE&gt;).required(<span class="bool-val">true</span>).action(ArgAction::Set))
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;two: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;two&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
    <span class="macro">println!</span>(
        <span class="string">&quot;one: {:?}&quot;</span>,
        matches.get_one::&lt;String&gt;(<span class="string">&quot;one&quot;</span>).expect(<span class="string">&quot;required&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 02_app_settings --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_app_settings[EXE] --two &lt;VALUE&gt; --one &lt;VALUE&gt;

Options:
      --two &lt;VALUE&gt;
          
      --one &lt;VALUE&gt;
          
  -h, --help
          Print help information
  -V, --version
          Print version information
</code></pre></div><h3 id="adding-arguments"><a href="#adding-arguments">Adding Arguments</a></h3><h4 id="positionals"><a href="#positionals">Positionals</a></h4>
<p>You can have users specify values by their position on the command-line:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>))
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional[EXE] [name]

Arguments:
  [name]  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_03_positional
name: None

$ 03_03_positional bob
name: Some(&quot;bob&quot;)
</code></pre></div>
<p>Note that the default <a href="../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a><code> is [</code>Set<code>][crate::ArgAction::Set].  To accept multiple values, use [</code>Append`]<a href="../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append">crate::ArgAction::Append</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>).action(ArgAction::Append))
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_03_positional_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_mult[EXE] [name]...

Arguments:
  [name]...  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_03_positional_mult
name: None

$ 03_03_positional_mult bob
name: Some(&quot;bob&quot;)
</code></pre></div><h4 id="options"><a href="#options">Options</a></h4>
<p>You can name your arguments with a flag:</p>
<ul>
<li>Order doesn’t matter</li>
<li>They can be optional</li>
<li>Intent is clearer</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(Arg::new(<span class="string">&quot;name&quot;</span>).short(<span class="string">&#39;n&#39;</span>).long(<span class="string">&quot;name&quot;</span>))
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option[EXE] [OPTIONS]

Options:
  -n, --name &lt;name&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 03_02_option
name: None

$ 03_02_option --name bob
name: Some(&quot;bob&quot;)

$ 03_02_option --name=bob
name: Some(&quot;bob&quot;)

$ 03_02_option -n bob
name: Some(&quot;bob&quot;)

$ 03_02_option -n=bob
name: Some(&quot;bob&quot;)

$ 03_02_option -nbob
name: Some(&quot;bob&quot;)
</code></pre></div>
<p>Note that the default <a href="../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a><code> is [</code>Set<code>][crate::ArgAction::Set].  To accept multiple occurrences, use [</code>Append`]<a href="../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append">crate::ArgAction::Append</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;name&quot;</span>)
                .short(<span class="string">&#39;n&#39;</span>)
                .long(<span class="string">&quot;name&quot;</span>)
                .action(ArgAction::Append),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;name: {:?}&quot;</span>, matches.get_one::&lt;String&gt;(<span class="string">&quot;name&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_02_option_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_mult[EXE] [OPTIONS]

Options:
  -n, --name &lt;name&gt;  
  -h, --help         Print help information
  -V, --version      Print version information

$ 03_02_option_mult
name: None

$ 03_02_option_mult --name bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult --name=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -n bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -n=bob
name: Some(&quot;bob&quot;)

$ 03_02_option_mult -nbob
name: Some(&quot;bob&quot;)
</code></pre></div><h4 id="flags"><a href="#flags">Flags</a></h4>
<p>Flags can also be switches that can be on/off:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;verbose&quot;</span>)
                .short(<span class="string">&#39;v&#39;</span>)
                .long(<span class="string">&quot;verbose&quot;</span>)
                .action(ArgAction::SetTrue),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, matches.get_flag(<span class="string">&quot;verbose&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_bool --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_bool[EXE] [OPTIONS]

Options:
  -v, --verbose  
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_01_flag_bool
verbose: false

$ 03_01_flag_bool --verbose
verbose: true

$ 03_01_flag_bool --verbose --verbose
? failed
error: The argument &#39;--verbose&#39; was provided more than once, but cannot be used multiple times

Usage: 03_01_flag_bool[EXE] [OPTIONS]

For more information try &#39;--help&#39;
</code></pre></div>
<p>Note that the default <a href="../builder/enum.ArgAction.html" title="crate::ArgAction"><code>ArgAction</code></a><code>for a</code>bool<code> field is [</code>SetTrue<code>][crate::ArgAction::SetTrue].  To accept multiple values, use [</code>Append`]<a href="../builder/enum.ArgAction.html#variant.Append" title="crate::ArgAction::Append">crate::ArgAction::Append</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{command, Arg, ArgAction};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            Arg::new(<span class="string">&quot;verbose&quot;</span>)
                .short(<span class="string">&#39;v&#39;</span>)
                .long(<span class="string">&quot;verbose&quot;</span>)
                .action(ArgAction::Count),
        )
        .get_matches();

    <span class="macro">println!</span>(<span class="string">&quot;verbose: {:?}&quot;</span>, matches.get_count(<span class="string">&quot;verbose&quot;</span>));
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_01_flag_count --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_count[EXE] [OPTIONS]

Options:
  -v, --verbose...  
  -h, --help        Print help information
  -V, --version     Print version information

$ 03_01_flag_count
verbose: 0

$ 03_01_flag_count --verbose
verbose: 1

$ 03_01_flag_count --verbose --verbose
verbose: 2
</code></pre></div><h4 id="subcommands"><a href="#subcommands">Subcommands</a></h4>
<p>Subcommands are defined as <a href="../builder/struct.Command.html" title="crate::Command"><code>Command</code></a>s that get added via
<a href="../builder/struct.Command.html#method.subcommand" title="crate::Command::subcommand"><code>Command::subcommand</code></a>. Each instance of a Subcommand can have its
own version, author(s), Args, and even its own subcommands.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, Command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.propagate_version(<span class="bool-val">true</span>)
        .subcommand_required(<span class="bool-val">true</span>)
        .arg_required_else_help(<span class="bool-val">true</span>)
        .subcommand(
            Command::new(<span class="string">&quot;add&quot;</span>)
                .about(<span class="string">&quot;Adds files to myapp&quot;</span>)
                .arg(<span class="macro">arg!</span>([NAME])),
        )
        .get_matches();

    <span class="kw">match </span>matches.subcommand() {
        <span class="prelude-val">Some</span>((<span class="string">&quot;add&quot;</span>, sub_matches)) =&gt; <span class="macro">println!</span>(
            <span class="string">&quot;&#39;myapp add&#39; was used, name is: {:?}&quot;</span>,
            sub_matches.get_one::&lt;String&gt;(<span class="string">&quot;NAME&quot;</span>)
        ),
        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(<span class="string">&quot;Exhausted list of subcommands and subcommand_required prevents `None`&quot;</span>),
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_04_subcommands help add
Adds files to myapp

Usage: 03_04_subcommands[EXE] add [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_04_subcommands add bob
&#39;myapp add&#39; was used, name is: Some(&quot;bob&quot;)
</code></pre></div>
<p>Because we set <a href="../builder/struct.Command.html#method.arg_required_else_help" title="crate::Command::arg_required_else_help"><code>Command::arg_required_else_help</code></a>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands
? failed
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] &lt;COMMAND&gt;

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help information
  -V, --version  Print version information
</code></pre></div>
<p>Because we set <a href="../builder/struct.Command.html#method.propagate_version" title="crate::Command::propagate_version"><code>Command::propagate_version</code></a>:</p>
<div class="example-wrap"><pre class="language-console"><code>$ 03_04_subcommands --version
clap [..]

$ 03_04_subcommands add --version
clap-add [..]
</code></pre></div><h4 id="defaults"><a href="#defaults">Defaults</a></h4>
<p>We’ve previously showed that arguments can be <a href="../builder/struct.Arg.html#method.required" title="crate::Arg::required"><code>required</code></a> or optional.
When optional, you work with a <code>Option</code> and can <code>unwrap_or</code>.  Alternatively, you can set
<a href="../builder/struct.Arg.html#method.default_value" title="crate::Arg::default_value"><code>Arg::default_value</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>([PORT])
                .value_parser(<span class="macro">value_parser!</span>(u16))
                .default_value(<span class="string">&quot;2020&quot;</span>),
        )
        .get_matches();

    <span class="macro">println!</span>(
        <span class="string">&quot;port: {:?}&quot;</span>,
        matches
            .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
            .expect(<span class="string">&quot;default ensures there is always a value&quot;</span>)
    );
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 03_05_default_values --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_05_default_values[EXE] [PORT]

Arguments:
  [PORT]  [default: 2020]

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 03_05_default_values
port: 2020

$ 03_05_default_values 22
port: 22
</code></pre></div><h3 id="validation"><a href="#validation">Validation</a></h3>
<p>By default, arguments are assumed to be <code>String</code>s and only UTF-8 validation is performed.</p>
<h4 id="enumerated-values"><a href="#enumerated-values">Enumerated values</a></h4>
<p>If you have arguments of specific values you want to test for, you can use the
<a href="../builder/struct.PossibleValuesParser.html" title="crate::builder::PossibleValuesParser"><code>PossibleValuesParser</code></a> or <a href="../builder/struct.Arg.html#method.value_parser" title="crate::Arg::value_parser"><code>Arg::value_parser([&quot;val1&quot;, ...])</code></a> for short.</p>
<p>This allows you specify the valid values for that argument. If the user does not use one of
those specific values, they will receive a graceful exit with error message informing them
of the mistake, and what the possible valid values are</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;MODE&gt;)
                .help(<span class="string">&quot;What mode to run the program in&quot;</span>)
                .value_parser([<span class="string">&quot;fast&quot;</span>, <span class="string">&quot;slow&quot;</span>]),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">match </span>matches
        .get_one::&lt;String&gt;(<span class="string">&quot;MODE&quot;</span>)
        .expect(<span class="string">&quot;&#39;MODE&#39; is required and parsing will fail if its missing&quot;</span>)
        .as_str()
    {
        <span class="string">&quot;fast&quot; </span>=&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Hare&quot;</span>);
        }
        <span class="string">&quot;slow&quot; </span>=&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Tortoise&quot;</span>);
        }
        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_01_possible --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_possible[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_01_possible fast
Hare

$ 04_01_possible slow
Tortoise

$ 04_01_possible medium
? failed
error: &quot;medium&quot; isn&#39;t a valid value for &#39;&lt;MODE&gt;&#39;
  [possible values: fast, slow]

For more information try &#39;--help&#39;
</code></pre></div>
<p>When enabling the <a href="../_features/index.html" title="crate::_features"><code>derive</code> feature</a>, you can use
<a href="../trait.ValueEnum.html" title="crate::ValueEnum"><code>ValueEnum</code></a> to take care of the boiler plate for you, giving the same
results.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, builder::PossibleValue, command, value_parser, ValueEnum};

<span class="attribute">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
</span><span class="kw">enum </span>Mode {
    Fast,
    Slow,
}

<span class="comment">// Can also be derived with feature flag `derive`
</span><span class="kw">impl </span>ValueEnum <span class="kw">for </span>Mode {
    <span class="kw">fn </span>value_variants&lt;<span class="lifetime">&#39;a</span>&gt;() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[<span class="self">Self</span>] {
        <span class="kw-2">&amp;</span>[Mode::Fast, Mode::Slow]
    }

    <span class="kw">fn </span>to_possible_value&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;PossibleValue&gt; {
        <span class="prelude-val">Some</span>(<span class="kw">match </span><span class="self">self </span>{
            Mode::Fast =&gt; PossibleValue::new(<span class="string">&quot;fast&quot;</span>),
            Mode::Slow =&gt; PossibleValue::new(<span class="string">&quot;slow&quot;</span>),
        })
    }
}

<span class="kw">impl </span>std::fmt::Display <span class="kw">for </span>Mode {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>std::fmt::Formatter&lt;<span class="lifetime">&#39;_</span>&gt;) -&gt; std::fmt::Result {
        <span class="self">self</span>.to_possible_value()
            .expect(<span class="string">&quot;no values are skipped&quot;</span>)
            .get_name()
            .fmt(f)
    }
}

<span class="kw">impl </span>std::str::FromStr <span class="kw">for </span>Mode {
    <span class="kw">type </span><span class="prelude-val">Err </span>= String;

    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">for </span>variant <span class="kw">in </span><span class="self">Self</span>::value_variants() {
            <span class="kw">if </span>variant.to_possible_value().unwrap().matches(s, <span class="bool-val">false</span>) {
                <span class="kw">return </span><span class="prelude-val">Ok</span>(<span class="kw-2">*</span>variant);
            }
        }
        <span class="prelude-val">Err</span>(<span class="macro">format!</span>(<span class="string">&quot;Invalid variant: {}&quot;</span>, s))
    }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;MODE&gt;)
                .help(<span class="string">&quot;What mode to run the program in&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(Mode)),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">match </span>matches
        .get_one::&lt;Mode&gt;(<span class="string">&quot;MODE&quot;</span>)
        .expect(<span class="string">&quot;&#39;MODE&#39; is required and parsing will fail if its missing&quot;</span>)
    {
        Mode::Fast =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Hare&quot;</span>);
        }
        Mode::Slow =&gt; {
            <span class="macro">println!</span>(<span class="string">&quot;Tortoise&quot;</span>);
        }
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_01_enum --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum[EXE] &lt;MODE&gt;

Arguments:
  &lt;MODE&gt;  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_01_enum fast
Hare

$ 04_01_enum slow
Tortoise

$ 04_01_enum medium
? failed
error: &quot;medium&quot; isn&#39;t a valid value for &#39;&lt;MODE&gt;&#39;
  [possible values: fast, slow]

For more information try &#39;--help&#39;
</code></pre></div><h4 id="validated-values"><a href="#validated-values">Validated values</a></h4>
<p>More generally, you can validate and parse into any data type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(u16).range(<span class="number">1</span>..)),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: u16 = <span class="kw-2">*</span>matches
        .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_parse --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_parse[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_02_parse 22
PORT = 22

$ 04_02_parse foobar
? failed
error: Invalid value &quot;foobar&quot; for &#39;&lt;PORT&gt;&#39;: invalid digit found in string

For more information try &#39;--help&#39;

$ 04_02_parse_derive 0
? failed
error: Invalid value &quot;0&quot; for &#39;&lt;PORT&gt;&#39;: 0 is not in 1..=65535

For more information try &#39;--help&#39;
</code></pre></div>
<p>A custom parser can be used to improve the error messages or provide additional validation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ops::RangeInclusive;

<span class="kw">use </span>clap::{arg, command};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(port_in_range),
        )
        .get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: u16 = <span class="kw-2">*</span>matches
        .get_one::&lt;u16&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}

<span class="kw">const </span>PORT_RANGE: RangeInclusive&lt;usize&gt; = <span class="number">1</span>..=<span class="number">65535</span>;

<span class="kw">fn </span>port_in_range(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;u16, String&gt; {
    <span class="kw">let </span>port: usize = s
        .parse()
        .map_err(|<span class="kw">_</span>| <span class="macro">format!</span>(<span class="string">&quot;`{}` isn&#39;t a port number&quot;</span>, s))<span class="question-mark">?</span>;
    <span class="kw">if </span>PORT_RANGE.contains(<span class="kw-2">&amp;</span>port) {
        <span class="prelude-val">Ok</span>(port <span class="kw">as </span>u16)
    } <span class="kw">else </span>{
        <span class="prelude-val">Err</span>(<span class="macro">format!</span>(
            <span class="string">&quot;Port not in range {}-{}&quot;</span>,
            PORT_RANGE.start(),
            PORT_RANGE.end()
        ))
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_02_validate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_validate[EXE] &lt;PORT&gt;

Arguments:
  &lt;PORT&gt;  Network port to use

Options:
  -h, --help     Print help information
  -V, --version  Print version information

$ 04_02_validate 22
PORT = 22

$ 04_02_validate foobar
? failed
error: Invalid value &quot;foobar&quot; for &#39;&lt;PORT&gt;&#39;: `foobar` isn&#39;t a port number

For more information try &#39;--help&#39;

$ 04_02_validate 0
? failed
error: Invalid value &quot;0&quot; for &#39;&lt;PORT&gt;&#39;: Port not in range 1-65535

For more information try &#39;--help&#39;
</code></pre></div>
<p>See <a href="../builder/struct.Arg.html#method.value_parser" title="crate::Arg::value_parser"><code>Arg::value_parser</code></a> for more details.</p>
<h4 id="argument-relations"><a href="#argument-relations">Argument Relations</a></h4>
<p>You can declare dependencies or conflicts between <a href="../builder/struct.Arg.html" title="crate::Arg"><code>Arg</code></a>s or even
<a href="../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s.</p>
<p><a href="../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s  make it easier to declare relations instead of having to list
each individually, or when you want a rule to apply “any but not all” arguments.</p>
<p>Perhaps the most common use of <a href="../builder/struct.ArgGroup.html" title="crate::ArgGroup"><code>ArgGroup</code></a>s is to require one and <em>only</em> one
argument to be present out of a given set. Imagine that you had multiple arguments, and you
want one of them to be required, but making all of them required isn’t feasible because perhaps
they conflict with each other.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction, ArgGroup};

<span class="kw">fn </span>main() {
    <span class="comment">// Create application like normal
    </span><span class="kw">let </span>matches = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        // Add the version arguments
        </span>.arg(<span class="macro">arg!</span>(--<span class="string">&quot;set-ver&quot; </span>&lt;VER&gt; <span class="string">&quot;set version manually&quot;</span>))
        .arg(<span class="macro">arg!</span>(--major         <span class="string">&quot;auto inc major&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--minor         <span class="string">&quot;auto inc minor&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--patch         <span class="string">&quot;auto inc patch&quot;</span>).action(ArgAction::SetTrue))
        <span class="comment">// Create a group, make it required, and add the above arguments
        </span>.group(
            ArgGroup::new(<span class="string">&quot;vers&quot;</span>)
                .required(<span class="bool-val">true</span>)
                .args([<span class="string">&quot;set-ver&quot;</span>, <span class="string">&quot;major&quot;</span>, <span class="string">&quot;minor&quot;</span>, <span class="string">&quot;patch&quot;</span>]),
        )
        <span class="comment">// Arguments can also be added to a group individually, these two arguments
        // are part of the &quot;input&quot; group which is not required
        </span>.arg(
            <span class="macro">arg!</span>([INPUT_FILE] <span class="string">&quot;some regular input&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .group(<span class="string">&quot;input&quot;</span>),
        )
        .arg(
            <span class="macro">arg!</span>(--<span class="string">&quot;spec-in&quot; </span>&lt;SPEC_IN&gt; <span class="string">&quot;some special input argument&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .group(<span class="string">&quot;input&quot;</span>),
        )
        <span class="comment">// Now let&#39;s assume we have a -c [config] argument which requires one of
        // (but **not** both) the &quot;input&quot; arguments
        </span>.arg(
            <span class="macro">arg!</span>(config: -c &lt;CONFIG&gt;)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf))
                .requires(<span class="string">&quot;input&quot;</span>),
        )
        .get_matches();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set-ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = matches.get_one::&lt;String&gt;(<span class="string">&quot;set-ver&quot;</span>) {
        ver.to_owned()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (
            matches.get_flag(<span class="string">&quot;major&quot;</span>),
            matches.get_flag(<span class="string">&quot;minor&quot;</span>),
            matches.get_flag(<span class="string">&quot;patch&quot;</span>),
        );
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="kw">_</span>, <span class="kw">_</span>) =&gt; major += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="bool-val">true</span>, <span class="kw">_</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="kw">_</span>, <span class="kw">_</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>(),
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if </span>matches.contains_id(<span class="string">&quot;config&quot;</span>) {
        <span class="kw">let </span>input = matches
            .get_one::&lt;PathBuf&gt;(<span class="string">&quot;INPUT_FILE&quot;</span>)
            .unwrap_or_else(|| matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;spec-in&quot;</span>).unwrap())
            .display();
        <span class="macro">println!</span>(
            <span class="string">&quot;Doing work using input {} and config {}&quot;</span>,
            input,
            matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>).unwrap().display()
        );
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_03_relations --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_03_relations[EXE] [OPTIONS] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help information
  -V, --version            Print version information

$ 04_03_relations
? failed
error: The following required arguments were not provided:
  &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt;

Usage: 04_03_relations[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_03_relations --major
Version: 2.2.3

$ 04_03_relations --major --minor
? failed
error: The argument &#39;--major&#39; cannot be used with &#39;--minor&#39;

Usage: 04_03_relations[EXE] &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_03_relations --major -c config.toml
? failed
error: The following required arguments were not provided:
  &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

Usage: 04_03_relations[EXE] -c &lt;CONFIG&gt; &lt;--set-ver &lt;VER&gt;|--major|--minor|--patch&gt; &lt;INPUT_FILE|--spec-in &lt;SPEC_IN&gt;&gt;

For more information try &#39;--help&#39;

$ 04_03_relations --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml
</code></pre></div><h4 id="custom-validation"><a href="#custom-validation">Custom Validation</a></h4>
<p>As a last resort, you can create custom errors with the basics of clap’s formatting.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::path::PathBuf;

<span class="kw">use </span>clap::error::ErrorKind;
<span class="kw">use </span>clap::{arg, command, value_parser, ArgAction};

<span class="kw">fn </span>main() {
    <span class="comment">// Create application like normal
    </span><span class="kw">let </span><span class="kw-2">mut </span>cmd = <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        // Add the version arguments
        </span>.arg(<span class="macro">arg!</span>(--<span class="string">&quot;set-ver&quot; </span>&lt;VER&gt; <span class="string">&quot;set version manually&quot;</span>))
        .arg(<span class="macro">arg!</span>(--major         <span class="string">&quot;auto inc major&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--minor         <span class="string">&quot;auto inc minor&quot;</span>).action(ArgAction::SetTrue))
        .arg(<span class="macro">arg!</span>(--patch         <span class="string">&quot;auto inc patch&quot;</span>).action(ArgAction::SetTrue))
        <span class="comment">// Arguments can also be added to a group individually, these two arguments
        // are part of the &quot;input&quot; group which is not required
        </span>.arg(<span class="macro">arg!</span>([INPUT_FILE] <span class="string">&quot;some regular input&quot;</span>).value_parser(<span class="macro">value_parser!</span>(PathBuf)))
        .arg(
            <span class="macro">arg!</span>(--<span class="string">&quot;spec-in&quot; </span>&lt;SPEC_IN&gt; <span class="string">&quot;some special input argument&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(PathBuf)),
        )
        <span class="comment">// Now let&#39;s assume we have a -c [config] argument which requires one of
        // (but **not** both) the &quot;input&quot; arguments
        </span>.arg(<span class="macro">arg!</span>(config: -c &lt;CONFIG&gt;).value_parser(<span class="macro">value_parser!</span>(PathBuf)));
    <span class="kw">let </span>matches = cmd.get_matches_mut();

    <span class="comment">// Let&#39;s assume the old version 1.2.3
    </span><span class="kw">let </span><span class="kw-2">mut </span>major = <span class="number">1</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>minor = <span class="number">2</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>patch = <span class="number">3</span>;

    <span class="comment">// See if --set-ver was used to set the version manually
    </span><span class="kw">let </span>version = <span class="kw">if let </span><span class="prelude-val">Some</span>(ver) = matches.get_one::&lt;String&gt;(<span class="string">&quot;set-ver&quot;</span>) {
        <span class="kw">if </span>matches.get_flag(<span class="string">&quot;major&quot;</span>) || matches.get_flag(<span class="string">&quot;minor&quot;</span>) || matches.get_flag(<span class="string">&quot;patch&quot;</span>) {
            cmd.error(
                ErrorKind::ArgumentConflict,
                <span class="string">&quot;Can&#39;t do relative and absolute version change&quot;</span>,
            )
            .exit();
        }
        ver.to_string()
    } <span class="kw">else </span>{
        <span class="comment">// Increment the one requested (in a real program, we&#39;d reset the lower numbers)
        </span><span class="kw">let </span>(maj, min, pat) = (
            matches.get_flag(<span class="string">&quot;major&quot;</span>),
            matches.get_flag(<span class="string">&quot;minor&quot;</span>),
            matches.get_flag(<span class="string">&quot;patch&quot;</span>),
        );
        <span class="kw">match </span>(maj, min, pat) {
            (<span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">false</span>) =&gt; major += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>) =&gt; minor += <span class="number">1</span>,
            (<span class="bool-val">false</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>) =&gt; patch += <span class="number">1</span>,
            <span class="kw">_ </span>=&gt; {
                cmd.error(
                    ErrorKind::ArgumentConflict,
                    <span class="string">&quot;Can only modify one version field&quot;</span>,
                )
                .exit();
            }
        };
        <span class="macro">format!</span>(<span class="string">&quot;{}.{}.{}&quot;</span>, major, minor, patch)
    };

    <span class="macro">println!</span>(<span class="string">&quot;Version: {}&quot;</span>, version);

    <span class="comment">// Check for usage of -c
    </span><span class="kw">if </span>matches.contains_id(<span class="string">&quot;config&quot;</span>) {
        <span class="kw">let </span>input = matches
            .get_one::&lt;PathBuf&gt;(<span class="string">&quot;INPUT_FILE&quot;</span>)
            .or_else(|| matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;spec-in&quot;</span>))
            .unwrap_or_else(|| {
                cmd.error(
                    ErrorKind::MissingRequiredArgument,
                    <span class="string">&quot;INPUT_FILE or --spec-in is required when using --config&quot;</span>,
                )
                .exit()
            })
            .display();
        <span class="macro">println!</span>(
            <span class="string">&quot;Doing work using input {} and config {}&quot;</span>,
            input,
            matches.get_one::&lt;PathBuf&gt;(<span class="string">&quot;config&quot;</span>).unwrap().display()
        );
    }
}</code></pre></div>
<div class="example-wrap"><pre class="language-console"><code>$ 04_04_custom --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver &lt;VER&gt;      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in &lt;SPEC_IN&gt;  some special input argument
  -c &lt;CONFIG&gt;              
  -h, --help               Print help information
  -V, --version            Print version information

$ 04_04_custom
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom --major
Version: 2.2.3

$ 04_04_custom --major --minor
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom --major -c config.toml
? failed
Version: 2.2.3
error: INPUT_FILE or --spec-in is required when using --config

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information try &#39;--help&#39;

$ 04_04_custom --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml
</code></pre></div><h3 id="testing"><a href="#testing">Testing</a></h3>
<p>clap reports most development errors as <code>debug_assert!</code>s.  Rather than checking every
subcommand, you should have a test that calls
<a href="../builder/struct.Command.html#method.debug_assert" title="crate::Command::debug_assert"><code>Command::debug_assert</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>clap::{arg, command, value_parser};

<span class="kw">fn </span>main() {
    <span class="kw">let </span>matches = cmd().get_matches();

    <span class="comment">// Note, it&#39;s safe to call unwrap() because the arg is required
    </span><span class="kw">let </span>port: usize = <span class="kw-2">*</span>matches
        .get_one::&lt;usize&gt;(<span class="string">&quot;PORT&quot;</span>)
        .expect(<span class="string">&quot;&#39;PORT&#39; is required and parsing will fail if its missing&quot;</span>);
    <span class="macro">println!</span>(<span class="string">&quot;PORT = {}&quot;</span>, port);
}

<span class="kw">fn </span>cmd() -&gt; clap::Command {
    <span class="macro">command!</span>() <span class="comment">// requires `cargo` feature
        </span>.arg(
            <span class="macro">arg!</span>(&lt;PORT&gt;)
                .help(<span class="string">&quot;Network port to use&quot;</span>)
                .value_parser(<span class="macro">value_parser!</span>(usize)),
        )
}

<span class="attribute">#[test]
</span><span class="kw">fn </span>verify_cmd() {
    cmd().debug_assert();
}</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="clap" data-themes="ayu,dark,light" data-resource-suffix="-20220928-1.66.0-nightly-ce7f0f1aa" data-rustdoc-version="1.66.0-nightly (ce7f0f1aa 2022-09-28)" ></div></body></html>